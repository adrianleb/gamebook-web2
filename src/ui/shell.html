<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>The Understage â€” DOS UI Shell Prototype</title>

  <!-- Preload VT323 font for performance -->
  <link rel="preload" href="https://fonts.gstatic.com/s/vt323/v15/pxiKyp0ihN8qnMr.woff2"
        as="font" type="font/woff2" crossorigin>

  <!-- Load VT323 font (SIL Open Font License) -->
  <link rel="stylesheet" href="https://fonts.googleapis.com/css2?family=VT323&display=swap">

  <!-- DOS UI styles -->
  <link rel="stylesheet" href="shell.css">
</head>
<body>
  <!-- Main game container -->
  <div class="game-container">

    <!-- HEADER -->
    <header class="game-header">
      <h1 class="game-title">The Understage</h1>
      <div class="header-actions">
        <button class="menu-button" id="btn-menu" aria-label="Open menu">MENU</button>
        <button class="menu-button" id="btn-save" aria-label="Save game">SAVE</button>
        <button class="menu-button" id="btn-load" aria-label="Load game">LOAD</button>
      </div>
    </header>

    <!-- MAIN TEXT VIEWPORT -->
    <main id="main-text"
          class="text-viewport"
          data-test-id="main-text-viewport"
          role="region"
          aria-label="Scene text"
          aria-live="polite"
          tabindex="0">
      <p id="scene-text" data-test-id="scene-text-content">
        The stage lights flicker, then die. In the sudden darkness, you hear the unmistakable
        <span class="italic">creak</span> of floorboardsâ€”boards that haven't been walked in
        <span class="bold">fifty years</span>.

      </p><p>
        <span class="speaker">DIRECTOR:</span> "You're late for your own disappearance."

      </p><p>
        The voice comes from everywhere and nowhere. This is <span class="faction-preservationist">The Understage</span>â€”the labyrinth
        beneath the theater where the <span class="bold">Preservationists</span> guard what
        <span class="faction-revisor">The Revisors</span> would rewrite.

      </p><p>
        Your pockets are empty. Your <span class="bold">Script</span> is blank. And somewhere
        in these dark corridors, your past is waiting.
      </p>
    </main>

    <!-- CHOICES PANEL -->
    <section id="choices-panel" class="choices-panel" data-test-id="choices-panel" aria-label="Available choices">
      <h2 class="choices-header">What do you do?</h2>
      <ul class="choices-list" data-test-id="choices-list" role="listbox">
        <li data-test-id="choice-0" data-choice-index="0">
          <button class="choice-button"
                  data-choice-number="1"
                  data-test-id="choice-button-0">
            Follow the voice into the darkness
          </button>
        </li>
        <li data-test-id="choice-1" data-choice-index="1">
          <button class="choice-button stat-check"
                  data-choice-number="2"
                  data-test-id="choice-button-1">
            <span class="stat-requirement" data-test-id="stat-check">[Script 6+]</span>
            Try to remember how you got here
          </button>
        </li>
        <li data-test-id="choice-2" data-choice-index="2">
          <button class="choice-button"
                  data-choice-number="3"
                  data-test-id="choice-button-2"
                  disabled
                  data-disabled-hint="Requires Key to Green Room"
                  aria-label="Choice 3: Check your pockets for the Key to Green Room â€” Requires Key to Green Room"
                  aria-disabled="true">
            Check your pockets for the <span class="bold">Key to Green Room</span>
            <span class="sr-only"> (Requires Key to Green Room)</span>
          </button>
        </li>
        <li data-test-id="choice-3" data-choice-index="3">
          <button class="choice-button"
                  data-choice-number="4"
                  data-test-id="choice-button-3">
            Call out into the darkness
          </button>
        </li>
      </ul>
    </section>

    <!-- BOTTOM PANEL: Stats + Inventory -->
    <div class="bottom-panel">

      <!-- STATS PANEL -->
      <aside id="stats-panel"
             class="stats-panel"
             data-test-id="stats-panel"
             role="region"
             aria-label="Character stats">
        <div class="panel-header">Status</div>

        <div class="stat-row" data-test-id="stat-script">
          <span class="stat-label">Script</span>
          <span class="stat-value">5/10</span>
        </div>
        <div class="stat-bar" data-stat-value="5" data-stat-max="10" aria-label="Script stat: 5 out of 10">
          <div class="stat-bar-segment filled"></div>
          <div class="stat-bar-segment filled"></div>
          <div class="stat-bar-segment filled"></div>
          <div class="stat-bar-segment filled"></div>
          <div class="stat-bar-segment filled"></div>
          <div class="stat-bar-segment"></div>
          <div class="stat-bar-segment"></div>
          <div class="stat-bar-segment"></div>
          <div class="stat-bar-segment"></div>
          <div class="stat-bar-segment"></div>
        </div>

        <div class="stat-row mt-3" data-test-id="stat-stage">
          <span class="stat-label">Stage Presence</span>
          <span class="stat-value">3/10</span>
        </div>
        <div class="stat-bar" data-stat-value="3" data-stat-max="10" aria-label="Stage Presence stat: 3 out of 10">
          <div class="stat-bar-segment filled"></div>
          <div class="stat-bar-segment filled"></div>
          <div class="stat-bar-segment filled"></div>
          <div class="stat-bar-segment"></div>
          <div class="stat-bar-segment"></div>
          <div class="stat-bar-segment"></div>
          <div class="stat-bar-segment"></div>
          <div class="stat-bar-segment"></div>
          <div class="stat-bar-segment"></div>
          <div class="stat-bar-segment"></div>
        </div>

        <div class="stat-row mt-3" data-test-id="stat-improv">
          <span class="stat-label">Improv</span>
          <span class="stat-value">7/10</span>
        </div>
        <div class="stat-bar" data-stat-value="7" data-stat-max="10" aria-label="Improv stat: 7 out of 10">
          <div class="stat-bar-segment filled"></div>
          <div class="stat-bar-segment filled"></div>
          <div class="stat-bar-segment filled"></div>
          <div class="stat-bar-segment filled"></div>
          <div class="stat-bar-segment filled"></div>
          <div class="stat-bar-segment filled"></div>
          <div class="stat-bar-segment filled"></div>
          <div class="stat-bar-segment"></div>
          <div class="stat-bar-segment"></div>
          <div class="stat-bar-segment"></div>
        </div>
      </aside>

      <!-- INVENTORY PANEL -->
      <aside id="inventory-panel"
             class="inventory-panel"
             data-test-id="inventory-panel"
             role="region"
             aria-label="Inventory items">
        <div class="panel-header">Inventory</div>
        <ul class="inventory-list" data-test-id="inventory-list">
          <li class="inventory-item" data-test-id="item-0" tabindex="0">
            <span class="item-icon">ðŸ“œ</span>
            <span class="item-name">Blank Script</span>
            <span class="item-category" class="sr-only">Script</span>
          </li>
          <li class="inventory-item" data-test-id="item-1" tabindex="0">
            <span class="item-icon">ðŸŽ­</span>
            <span class="item-name">Rehearsal Props</span>
            <span class="item-category">Props</span>
            <span class="item-quantity">x3</span>
          </li>
          <li class="inventory-item" data-test-id="item-2" tabindex="0">
            <span class="item-icon">ðŸ”¦</span>
            <span class="item-name">Stage Light Fuse</span>
            <span class="item-category">Token</span>
          </li>
          <li class="inventory-item" data-test-id="item-3" tabindex="0">
            <span class="item-icon">ðŸŽ«</span>
            <span class="item-name">Ticket to Archives</span>
            <span class="item-category">Key</span>
          </li>
        </ul>
      </aside>

    </div>
    <!-- End bottom panel -->

  </div>
  <!-- End game container -->

  <!-- ERROR OVERLAY (hidden by default) -->
  <div id="error-overlay"
       class="error-overlay"
       data-test-id="error-overlay"
       role="alertdialog"
       aria-labelledby="error-title"
       aria-describedby="error-text"
       aria-hidden="true">
    <div class="error-message">
      <h2 id="error-title" class="error-title" data-test-id="error-title">Error</h2>
      <p id="error-text" class="error-text" data-test-id="error-message">
        Scene not found. Please report this bug.
      </p>
      <button id="error-dismiss" class="error-button" data-test-id="error-dismiss">
        Continue
      </button>
    </div>
  </div>

  <!-- LOADING INDICATOR (hidden by default) -->
  <div id="loading-indicator" class="loading-indicator" aria-hidden="true"></div>

  <!-- MOCK EVENT DISPATCHER FOR PROTOTYPE -->
  <script>
    /**
     * MOCK ENGINE EVENT SYSTEM
     * Demonstrates UI subscription to engine state changes
     * Per agent-c's RFC: synchronous emission, async UI updates
     */

    // Mock StateChangeEvent structure (per engine RFC)
    /*
    interface StateChangeEvent {
      type: 'scene-loaded' | 'condition-evaluated' | 'effect-applied' | 'state-changed' | 'font-ready';
      path: string;           // e.g., 'stats.courage', 'inventory.[2]'
      oldValue: any;
      newValue: any;
      renderScope?: 'all' | 'viewport' | 'choices' | 'stats' | 'inventory';
      urgency?: 'high' | 'normal' | 'low';
    }
    */

    class MockEngine {
      constructor() {
        this.subscribers = [];
        this.state = {
          currentScene: 'sc_1_1_001',
          stats: { script: 5, stagePresence: 3, improv: 7 },
          inventory: [
            { id: 'blank_script', name: 'Blank Script', icon: 'ðŸ“œ', category: 'Scripts' },
            { id: 'rehearsal_props', name: 'Rehearsal Props', icon: 'ðŸŽ­', category: 'Props', quantity: 3 },
            { id: 'stage_light_fuse', name: 'Stage Light Fuse', icon: 'ðŸ”¦', category: 'Tokens' },
            { id: 'ticket_archives', name: 'Ticket to Archives', icon: 'ðŸŽ«', category: 'Keys' }
          ],
          availableChoices: [
            { id: 0, text: 'Follow the voice into the darkness', statCheck: null, locked: false, disabledHint: null },
            { id: 1, text: 'Try to remember how you got here', statCheck: { stat: 'script', threshold: 6 }, locked: false, disabledHint: null },
            { id: 2, text: 'Check your pockets for the Key to Green Room', statCheck: null, locked: true, disabledHint: 'Requires Key to Green Room' },
            { id: 3, text: 'Call out into the darkness', statCheck: null, locked: false, disabledHint: null }
          ]
        };
      }

      // Subscribe to state changes (per engine RFC)
      subscribe(callback) {
        this.subscribers.push(callback);
      }

      // Emit state change event (synchronous)
      emit(event) {
        this.subscribers.forEach(callback => {
          // Async UI update per agent-c perspective
          setTimeout(() => callback(event), 0);
        });
      }

      // Mock: Load scene
      loadScene(sceneId) {
        const oldScene = this.state.currentScene;
        this.state.currentScene = sceneId;

        this.emit({
          type: 'scene-loaded',
          path: 'currentScene',
          oldValue: oldScene,
          newValue: sceneId,
          renderScope: 'all',
          urgency: 'high'
        });
      }

      // Mock: Apply stat change
      changeStat(stat, delta) {
        const oldValue = this.state.stats[stat];
        const newValue = Math.max(0, Math.min(10, oldValue + delta));
        this.state.stats[stat] = newValue;

        this.emit({
          type: 'effect-applied',
          path: `stats.${stat}`,
          oldValue: oldValue,
          newValue: newValue,
          renderScope: 'stats',
          urgency: 'normal'
        });
      }

      // Mock: Font ready event
      fontReady() {
        this.emit({
          type: 'font-ready',
          path: 'ui.fontLoaded',
          oldValue: false,
          newValue: true,
          renderScope: 'all',
          urgency: 'high'
        });
      }
    }

    // UI Controller - subscribes to engine events
    class UIController {
      constructor(engine) {
        this.engine = engine;

        // DOM elements (with test attributes per agent-e requirements)
        this.elements = {
          viewport: document.querySelector('[data-test-id="main-text-viewport"]'),
          choicesList: document.querySelector('[data-test-id="choices-list"]'),
          statsPanel: document.querySelector('[data-test-id="stats-panel"]'),
          inventoryList: document.querySelector('[data-test-id="inventory-list"]'),
          errorOverlay: document.querySelector('[data-test-id="error-overlay"]'),
          loadingIndicator: document.querySelector('[data-test-id="loading-indicator"]')
        };

        // Subscribe to engine events
        this.engine.subscribe(this.handleStateChange.bind(this));

        // Setup keyboard navigation
        this.setupKeyboardNav();

        // Setup choice button handlers
        this.setupChoices();
      }

      // Handle state change events
      handleStateChange(event) {
        console.log('[UI] State change:', event);

        switch (event.renderScope) {
          case 'all':
            this.renderAll();
            break;
          case 'viewport':
            this.renderViewport();
            break;
          case 'choices':
            this.renderChoices();
            break;
          case 'stats':
            this.renderStats();
            break;
          case 'inventory':
            this.renderInventory();
            break;
        }
      }

      // Render all UI components
      renderAll() {
        this.renderViewport();
        this.renderChoices();
        this.renderStats();
        this.renderInventory();
      }

      // Render main text viewport with DOS-style transition
      renderViewport() {
        const viewport = this.elements.viewport;
        viewport.classList.add('transitioning');

        // Mock: Update text content
        setTimeout(() => {
          // Text swap would happen here via engine state
        }, 250); // Midpoint of 500ms transition

        setTimeout(() => {
          viewport.classList.remove('transitioning');
        }, 500);
      }

      // Render choices panel
      renderChoices() {
        const choices = this.engine.state.availableChoices;
        const list = this.elements.choicesList;
        list.innerHTML = '';

        choices.forEach((choice, index) => {
          const li = document.createElement('li');
          li.setAttribute('data-test-id', `choice-${index}`);
          li.setAttribute('data-choice-index', index);

          const button = document.createElement('button');
          button.className = 'choice-button';
          button.setAttribute('data-choice-number', index + 1);
          button.setAttribute('data-choice-index', index);
          button.setAttribute('data-test-id', `choice-button-${index}`);
          button.textContent = choice.text;

          if (choice.locked) {
            button.disabled = true;
            button.setAttribute('aria-disabled', 'true');

            // Add disabled hint for accessibility and visual display
            const hint = choice.disabledHint || 'Locked';
            button.setAttribute('data-disabled-hint', hint);
            button.setAttribute('aria-label', `Choice ${index + 1}: ${choice.text} â€” ${hint}`);

            // Add sr-only text for screen readers
            const srText = document.createElement('span');
            srText.className = 'sr-only';
            srText.textContent = ` (${hint})`;
            button.appendChild(srText);
          } else {
            button.setAttribute('aria-label', `Choice ${index + 1}: ${choice.text}`);
          }

          if (choice.statCheck) {
            button.classList.add('stat-check');
            const reqSpan = document.createElement('span');
            reqSpan.className = 'stat-requirement';
            reqSpan.setAttribute('data-test-id', 'stat-check');
            reqSpan.textContent = `[${choice.statCheck.stat.charAt(0).toUpperCase() + choice.statCheck.stat.slice(1)} ${choice.statCheck.threshold}+]`;
            button.prepend(reqSpan);
          }

          button.addEventListener('click', () => this.handleChoice(choice.id));
          li.appendChild(button);
          list.appendChild(li);
        });

        // Update tab indexes after rendering
        this.updateChoiceTabIndexes();
      }

      // Render stats panel
      renderStats() {
        const stats = this.engine.state.stats;
        // Update stat bars
        // (Full implementation would update DOM based on state)
      }

      // Render inventory panel
      renderInventory() {
        const inventory = this.engine.state.inventory;
        // Update inventory list
        // (Full implementation would update DOM based on state)
      }

      // Handle choice selection
      handleChoice(choiceId) {
        console.log('[UI] Choice selected:', choiceId);
        const button = document.querySelector(`[data-choice-index="${choiceId}"] .choice-button`);
        button.classList.add('selected');

        // Mock: Transition to next scene
        setTimeout(() => {
          this.engine.loadScene('sc_1_1_002');
        }, 300); // DOS-style 300ms delay
      }

      // Setup keyboard navigation (per agent-e requirements)
      setupKeyboardNav() {
        const choicesList = this.elements.choicesList;

        choicesList.addEventListener('keydown', (e) => {
          const allButtons = Array.from(choicesList.querySelectorAll('.choice-button'));
          const enabledButtons = allButtons.filter(btn => !btn.disabled);
          const currentFocused = document.activeElement;
          const currentIndex = enabledButtons.indexOf(currentFocused);

          switch (e.key) {
            case 'ArrowDown':
              e.preventDefault();
              this.focusNextChoice(enabledButtons, currentIndex);
              break;

            case 'ArrowUp':
              e.preventDefault();
              this.focusPreviousChoice(enabledButtons, currentIndex);
              break;

            case 'Home':
              e.preventDefault();
              if (enabledButtons.length > 0) enabledButtons[0].focus();
              break;

            case 'End':
              e.preventDefault();
              if (enabledButtons.length > 0) enabledButtons[enabledButtons.length - 1].focus();
              break;

            case 'Escape':
              // Toggle inventory
              this.elements.inventoryList.parentElement.classList.toggle('collapsed');
              break;

            case '1':
            case '2':
            case '3':
            case '4':
            case '5':
            case '6':
            case '7':
            case '8':
            case '9':
              // Quick select choice - only enabled choices
              const choiceIndex = parseInt(e.key) - 1;
              const choice = this.engine.state.availableChoices[choiceIndex];
              if (choice && !choice.locked) {
                this.handleChoice(choiceIndex);
              }
              e.preventDefault();
              break;
          }
        });

        // Initialize: Set first enabled choice as focusable
        this.updateChoiceTabIndexes();
      }

      focusNextChoice(enabledButtons, currentIndex) {
        let nextIndex = currentIndex + 1;
        if (nextIndex >= enabledButtons.length) nextIndex = 0; // Wrap to first
        if (enabledButtons[nextIndex]) enabledButtons[nextIndex].focus();
      }

      focusPreviousChoice(enabledButtons, currentIndex) {
        let prevIndex = currentIndex - 1;
        if (prevIndex < 0) prevIndex = enabledButtons.length - 1; // Wrap to last
        if (enabledButtons[prevIndex]) enabledButtons[prevIndex].focus();
      }

      updateChoiceTabIndexes() {
        const allButtons = this.elements.choicesList.querySelectorAll('.choice-button');
        allButtons.forEach(btn => btn.tabIndex = -1);

        const enabledButtons = Array.from(allButtons).filter(btn => !btn.disabled);
        enabledButtons.forEach(btn => btn.tabIndex = 0);

        if (enabledButtons.length > 0) {
          enabledButtons[0].focus();
        }
      }

      // Setup choice button handlers
      setupChoices() {
        const buttons = document.querySelectorAll('.choice-button:not(.locked)');
        buttons.forEach((button, index) => {
          button.addEventListener('click', () => {
            this.handleChoice(index);
          });
        });
      }
    }

    // Initialize mock engine and UI controller
    document.addEventListener('DOMContentLoaded', () => {
      console.log('[DOS UI Shell] Prototype initialized');

      const engine = new MockEngine();
      const ui = new UIController(engine);

      // Emit font-ready event after VT323 loads
      if (document.fonts) {
        document.fonts.ready.then(() => {
          console.log('[DOS UI Shell] VT323 font loaded');
          engine.fontReady();
        });
      }

      // Demo: Simulate state changes
      setTimeout(() => {
        console.log('[Demo] Simulating stat change...');
        engine.changeStat('script', 1);
      }, 5000);
    });

    // Error overlay handler
    document.getElementById('error-dismiss').addEventListener('click', () => {
      document.getElementById('error-overlay').classList.remove('visible');
      document.getElementById('error-overlay').setAttribute('aria-hidden', 'true');
    });
  </script>

</body>
</html>
